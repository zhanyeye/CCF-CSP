#include <iostream>
#include <cstring>
#define LL long long
using namespace std;    

//2肯定是在首位的，因为2必须在3的前面，而0必须在1的前面，而且0不能在首位，那么显而易见的首位只能是2.

// 这题是典型的数位dp，第 n 位可以利用第 n-1 位的结果， 将其分为6种状态如下：

// 1. 只含2            =>   222_2
// 2. 只含2、0         =>   222_0、  2020_2、 2020_0
// 3. 只含2、3         =>   2233_3、222_3
// 4. 只含2、0、1      =>   2200_1、220011_2、220011_1
// 5. 只含2、0、3      =>   2233_0、2200_3、223300_0、223300_3
// 6. 含4种数字        =>    201_3、203_1、2013_3、 2013_1、2031_1、2031_3

// dp[i][j]表示位数为 i，符合状态 j 的（6种）合法的数的个数。
// 对于状态1: dp[i][1] = 1   因为只有一种可能
// 对于状态2: dp[i][2] = dp[i-1][1] + dp[i-1][2] * 2
//     位数为 i 且只含 2、0 的整数可以由位数为 i-1 的只含 2 的数在末尾添加0 得到，也可以通过 位数 i-1 的只含0、2 的数在末尾添加 0或2 组成
// 对于转态3：dp[i][3] = dp[i-1][1] + dp[i-1][3]
//     位数为i 且只含2、3 的整数可以由 位数为 i-1 的只含 2 的数在末尾添加3得到，也可以通过位数为 i-1 的 只含2、3的整数 在末尾添加3得到
//     注： 数字2必须在3之前
// 对于状态4: dp[i][4] = dp[i-1][2] + dp[i-1][4] * 2
// 对于状态5：dp[i][5] = dp[i-1][2] + dp[i-1][3] + dp[i-1][5] * 2
// 对于状态6：dp[i][6] = dp[i-1][4] + dp[i-1][5] + dp[i-1][6] * 2


const int MOD = 1000000007;
LL dp[1001][7];

int main() {
    int n;
    cin >> n;
    memset(dp, 0, sizeof dp);
    for (int i = 1; i <= n; i++) { //dp[i][j] 表示位数为 i，符合状态 j （6种）的合法的数的个数。
        dp[i][1] = 1; // 只含 2
        dp[i][2] = (dp[i-1][1] + dp[i-1][2] * 2) % MOD; // 只含 2 0
        dp[i][3] = (dp[i-1][1] + dp[i-1][3]) % MOD; // 只含 2 3
        dp[i][4] = (dp[i-1][2] + dp[i-1][4] * 2) % MOD; // 只含 2 0 1
        dp[i][5] = (dp[i-1][2] + dp[i-1][3] + dp[i-1][5] * 2) % MOD; // 只含 2 3 0
        dp[i][6] = (dp[i-1][4] + dp[i-1][5] + dp[i-1][6] * 2) % MOD; // 4个数字都包含
    }
    cout << dp[n][6] << endl;
}